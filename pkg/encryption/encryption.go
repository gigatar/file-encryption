// Package encryption provides file encryption and decryption functionality using AES-GCM-SIV.
// It implements secure file encryption with password-based key derivation and supports
// chunked processing for large files.
//
// The package uses AES-GCM-SIV (Galois/Counter Mode with Synthetic Initialization Vector)
// for authenticated encryption, which provides both confidentiality and authenticity.
// The encryption process includes:
//   - Password-based key derivation using Argon2id
//   - Random salt generation for each file
//   - Synthetic IV generation for nonce reuse protection
//   - Chunked processing for handling large files
//   - Authenticated encryption with associated data (AEAD)
//
// Security features:
//   - Each file uses a unique salt to prevent rainbow table attacks
//   - Synthetic IVs prevent nonce reuse vulnerabilities
//   - Chunked processing with length prefixes prevents truncation attacks
//   - AEAD ensures data integrity and authenticity
//
// File Format:
// The encrypted file format is structured as follows:
//
//	[salt (16 bytes)][chunk1][chunk2]...[chunkN]
//
// Each chunk has the format:
//
//	[nonce (12 bytes)][length (4 bytes)][encrypted data]
//
// Security Considerations:
//
//  1. Key Derivation:
//     - Uses Argon2id for memory-hard key derivation
//     - Each file has a unique salt to prevent rainbow table attacks
//     - Salt is stored with the encrypted file
//
//  2. Encryption:
//     - AES-GCM-SIV provides authenticated encryption
//     - Synthetic IVs prevent nonce reuse vulnerabilities
//     - Each chunk has a unique nonce (incremented counter)
//
//  3. File Processing:
//     - Chunked processing allows handling of large files
//     - Length prefixes prevent truncation attacks
//     - AEAD ensures data integrity for each chunk
//
//  4. Memory Safety:
//     - No sensitive data is kept in memory longer than necessary
//     - Chunk size is fixed to prevent memory exhaustion
//     - File handles are properly closed using defer
//
// Usage Example:
//
//	err := encryption.EncryptFile("input.txt", "output.enc")
//	if err != nil {
//	    log.Fatal(err)
//	}
//
//	err = encryption.DecryptFile("output.enc", "decrypted.txt")
//	if err != nil {
//	    log.Fatal(err)
//	}
//
// Dependencies:
//   - crypto/aes: For AES encryption
//   - crypto/cipher: For GCM-SIV mode
//   - crypto/rand: For secure random number generation
//   - pkg/kdf: For password-based key derivation
package encryption

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/binary"
	"io"
	"os"

	"github.com/gigatar/file-encryptor/pkg/kdf"
)

// Constants for encryption configuration
const (
	// chunkSize defines the size of chunks for processing large files.
	// The value of 64KB provides a good balance between memory usage
	// and performance for most file sizes.
	chunkSize = 64 * 1024 // 64KB

	// saltSize defines the length of the random salt used for key derivation.
	// A 16-byte (128-bit) salt provides sufficient entropy to prevent
	// rainbow table attacks while keeping the overhead minimal.
	saltSize = 16
)

// generateSalt creates a new random salt for key derivation.
// The salt is used to prevent rainbow table attacks and ensure
// that the same password produces different keys for different files.
//
// Returns:
//   - []byte: A random salt of length saltSize
//   - error: Any error that occurred during salt generation
func generateSalt() ([]byte, error) {
	salt := make([]byte, saltSize)
	if _, err := rand.Read(salt); err != nil {
		return nil, err
	}

	return salt, nil
}

// generateSyntheticIV creates a synthetic initialization vector (IV) for AES-GCM-SIV.
// The IV is generated by encrypting a zero block and XORing it with the plaintext.
// This ensures that the IV is unique for each encryption operation and
// provides additional security against nonce reuse.
//
// Args:
//   - key: The encryption key to use
//   - plainText: The plaintext data to be encrypted
//
// Returns:
//   - []byte: A 12-byte synthetic IV
//   - error: Any error that occurred during IV generation
func generateSyntheticIV(key []byte, plainText []byte) ([]byte, error) {
	// Create Zero block
	zeroBlock := make([]byte, 16)

	// Encrypt Zeroblock to create initial block
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	blockCipherText := make([]byte, 16)
	block.Encrypt(blockCipherText, zeroBlock)

	// XOR the result of encryption with the plaintext to create the IV
	syntheticIV := make([]byte, 12)
	copy(syntheticIV, blockCipherText[:12]) // Only need first 12 bytes for IV
	for i := 0; i < len(plainText) && i < len(syntheticIV); i++ {
		syntheticIV[i] ^= plainText[i]
	}

	return syntheticIV, nil
}

// EncryptFile encrypts a file using AES-GCM-SIV encryption.
// It reads the input file, encrypts its contents using a password-derived key,
// and writes the encrypted data to the output file.
//
// The encryption process:
//  1. Generates a random salt and writes it to the output file
//  2. Derives an encryption key from the user's password and salt
//  3. Reads the first chunk of data and generates a synthetic IV
//  4. Encrypts the first chunk and writes it to the output file
//  5. Processes remaining chunks with incrementing nonce values
//
// The output file format is:
//
//	[salt (16 bytes)][nonce (12 bytes)][length (4 bytes)][encrypted chunk][...]
//
// Args:
//   - inName: Path to the file to encrypt
//   - outName: Path where the encrypted file will be written
//
// Returns:
//   - error: Any error that occurred during encryption
func EncryptFile(inName, outName string) error {
	inFile, err := os.Open(inName)
	if err != nil {
		return err
	}
	defer inFile.Close()

	outFile, err := os.Create(outName)
	if err != nil {
		return err
	}
	defer outFile.Close()

	salt, err := generateSalt()
	if err != nil {
		return err
	}

	key, err := kdf.GetKey(salt)
	if err != nil {
		return err
	}

	if _, err := outFile.Write(salt); err != nil {
		return err
	}

	firstChunk := make([]byte, chunkSize)
	n, err := inFile.Read(firstChunk)
	if err != nil && err != io.EOF {
		return err
	}
	nonce, err := generateSyntheticIV(key, firstChunk[:n])
	if err != nil {
		return err
	}

	// write nonce to output file
	if _, err := outFile.Write(nonce); err != nil {
		return err
	}

	// Encrypt and write first chunk
	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return err
	}

	ct := gcm.Seal(nil, nonce, firstChunk[:n], nil)

	// Write length
	lenBuf := make([]byte, 4)
	binary.BigEndian.PutUint32(lenBuf, uint32(len(ct)))
	if _, err := outFile.Write(lenBuf); err != nil {
		return err
	}

	if _, err := outFile.Write(ct); err != nil {
		return err
	}

	nonceCounter := uint64(0)
	// Process rest of file
	for {
		n, err := inFile.Read(firstChunk)
		if err != nil && err != io.EOF {
			return err
		}
		if n == 0 {
			break
		}

		binary.BigEndian.PutUint64(nonce[4:], nonceCounter)
		nonceCounter++

		if _, err := outFile.Write(nonce); err != nil {
			return err
		}
		ct := gcm.Seal(nil, nonce, firstChunk[:n], nil)
		lenBuf := make([]byte, 4)
		binary.BigEndian.PutUint32(lenBuf, uint32(len(ct)))
		if _, err := outFile.Write(lenBuf); err != nil {
			return err
		}

		if _, err := outFile.Write(ct); err != nil {
			return err
		}
	}

	return nil
}

// DecryptFile decrypts a previously encrypted file.
// It reads the encrypted file, decrypts its contents using the provided password,
// and writes the decrypted data to the output file.
//
// The decryption process:
//  1. Reads the salt from the start of the encrypted file
//  2. Derives the decryption key from the user's password and salt
//  3. For each chunk:
//     a. Reads the nonce and chunk length
//     b. Reads the encrypted chunk
//     c. Decrypts the chunk and writes it to the output file
//
// Args:
//   - inName: Path to the encrypted file
//   - outName: Path where the decrypted file will be written
//
// Returns:
//   - error: Any error that occurred during decryption
func DecryptFile(inName, outName string) error {
	inFile, err := os.Open(inName)
	if err != nil {
		return err
	}
	defer inFile.Close()

	outFile, err := os.Create(outName)
	if err != nil {
		return err
	}
	defer outFile.Close()

	salt := make([]byte, saltSize)
	if _, err := io.ReadFull(inFile, salt); err != nil {
		return err
	}

	key, err := kdf.GetKey(salt)
	if err != nil {
		return err
	}

	// Create GCM Cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return err
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil
	}

	nonce := make([]byte, 12)
	lenBuf := make([]byte, 4)
	for {
		// Read Nonce
		if _, err := io.ReadFull(inFile, nonce); err != nil {
			if err == io.EOF {
				break
			} else {
				return err
			}
		}
		if _, err := io.ReadFull(inFile, lenBuf); err != nil {
			return err
		}

		ctLen := binary.BigEndian.Uint32(lenBuf)
		ct := make([]byte, ctLen)

		if _, err := io.ReadFull(inFile, ct); err != nil {
			return err
		}

		// Decrypt
		pt, err := gcm.Open(nil, nonce, ct, nil)
		if err != nil {
			return err
		}

		if _, err := outFile.Write(pt); err != nil {
			return err
		}
	}

	return nil
}
